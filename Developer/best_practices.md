# Лучшие практики Laravel

Этот документ содержит набор лучших практик и рекомендаций по работе с фреймворком Laravel, которые не относятся напрямую к стилю кода или именованию, но критически важны для создания качественных, безопасных и производительных приложений.

---

## 1. Валидация: Используйте Form Requests

Вместо того чтобы размещать логику валидации в контроллере, всегда выносите её в специализированные классы `Form Request`.

*   **Причина:** Это очищает контроллер (принцип "тонких" контроллеров), делает правила валидации переиспользуемыми и позволяет легко тестировать их отдельно. Laravel автоматически выполняет валидацию и редиректит пользователя назад с ошибками, если она не прошла.
*   **✅ Правильно:**
    ```php
    // app/Http/Requests/StorePostRequest.php
    public function rules(): array
    {
        return [
            'title' => 'required|unique:posts|max:255',
            'body' => 'required',
        ];
    }

    // PostController.php
    public function store(StorePostRequest $request)
    {
        // Валидация уже прошла автоматически. Мы работаем только с проверенными данными.
        Post::create($request->validated());

        return redirect()->route('posts.index');
    }
    ```
*   **❌ Неправильно (логика валидации в контроллере):**
    ```php
    // PostController.php
    public function store(Request $request)
    {
        $validated = $request->validate([
            'title' => 'required|unique:posts|max:255',
            'body' => 'required',
        ]);

        Post::create($validated);

        return redirect()->route('posts.index');
    }
    ```

## 2. Eloquent > Query Builder > Raw SQL

Предпочитайте использовать Eloquent ORM, когда это возможно. Используйте Query Builder, если запрос слишком сложен для Eloquent, и "сырые" SQL-запросы в крайнем случае.

*   **Причина:** Eloquent предоставляет чистый, выразительный синтаксис, автоматически защищает от SQL-инъекций и позволяет использовать свои мощные возможности: отношения, аксессоры/мутаторы, области видимости (scopes) и события моделей.
*   **✅ Правильно (Eloquent):**
    ```php
    $activeUsers = User::where('active', 1)->get();
    ```
*   **⚠️ Допустимо (Query Builder):**
    ```php
    $activeUsers = DB::table('users')->where('active', 1)->get();
    ```
*   **❌ Неправильно (Raw SQL, если можно избежать):**
    ```php
    $activeUsers = DB::select('SELECT * FROM users WHERE active = 1');
    ```

## 3. Безопасность: Mass Assignment

Всегда защищайте свои модели от уязвимости Mass Assignment, используя свойства `$fillable` (белый список) или `$guarded` (черный список). Предпочтительнее использовать `$fillable` для явного контроля.

*   **Причина:** Это предотвращает ситуацию, когда злоумышленник может передать в HTTP-запросе дополнительные поля (например, `is_admin=1` или `role_id=1`) и обновить в базе данных то, что не должно было быть изменено.
*   **✅ Правильно:**
    ```php
    // app/Models/User.php
    class User extends Model
    {
        // Разрешаем массовое заполнение только этих полей
        protected $fillable = ['name', 'email', 'password'];
    }

    // В контроллере
    User::create($request->all()); // Безопасно
    ```
*   **❌ Неправильно (отключает защиту):**
    ```php
    // app/Models/User.php
    class User extends Model
    {
        // Опасно, если в $request->all() могут быть нежелательные поля
        protected $guarded = [];
    }
    ```

## 4. Конфигурация: `config()` вместо `env()`

В коде приложения всегда используйте хелпер `config()`. Хелпер `env()` должен использоваться **только** внутри файлов конфигурации (`config/*.php`).

*   **Причина:**
    1.  **Производительность:** Laravel кеширует файлы конфигурации в один файл командой `php artisan config:cache`. Вызовы `env()` не используют этот кеш и каждый раз читают `.env` файл, что значительно медленнее.
    2.  **Надёжность:** На продакшене `.env` файл может отсутствовать, если переменные окружения заданы на уровне сервера. В этом случае `env('DB_HOST')` вернёт `null`, что приведёт к ошибке, в то время как `config('database.connections.mysql.host')` вернёт значение из кеша.
*   **✅ Правильно:**
    ```php
    // config/services.php
    'stripe' => [
        'secret' => env('STRIPE_SECRET'), // env() используется только здесь
    ],

    // В коде вашего приложения
    $stripeSecret = config('services.stripe.secret');
    ```
*   **❌ Неправильно:**
    ```php
    // Этот код сломается при кешировании конфигурации
    $stripeSecret = env('STRIPE_SECRET');
    ```

## 5. Используйте стандартные инструменты фреймворка

*   **Даты и время:** Всегда используйте `Carbon`. Для получения текущего времени используйте глобальный хелпер `now()` или `Carbon::now()`, а не нативные функции PHP.
*   **IoC-контейнер:** Не создавайте экземпляры сервисов и других классов с зависимостями вручную через `new`. Позвольте Laravel внедрить их через конструктор или используйте хелпер `app()`.
*   **Artisan:** Используйте встроенные `make` команды (`make:model`, `make:controller` и т.д.) для генерации классов. Это обеспечивает правильную структуру и расположение файлов.
*   **Ресурсы (assets):** Для ссылок на CSS/JS/изображения всегда используйте хелпер `asset()`. Он генерирует правильный URL с учётом настроек вашего приложения.
*   **Поиск моделей:** Используйте `findOrFail()` или `firstOrFail()`, чтобы автоматически выбрасывать исключение `ModelNotFoundException` (которое Laravel превратит в HTTP-ответ 404), если модель не найдена.

    *   **✅ Правильно:**
        ```php
        $post = Post::findOrFail($id);
        ```
    *   **❌ Неправильно (требует ручной проверки):**
        ```php
        $post = Post::find($id);
        if (!$post) {
            abort(404);
        }
        ```
