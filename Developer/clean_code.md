# Принципы чистого кода в Laravel

Этот документ — руководство по написанию чистого, поддерживаемого и эффективного кода в Laravel. Чистый код понятен, его легко изменять, и он содержит меньше ошибок.

---

## 1. Контроллеры: Тонкие и сфокусированные

### ✅ Правильно: Контроллер делегирует бизнес-логику

Контроллер должен быть "тонким". Его единственная задача — принять HTTP-запрос, передать данные в соответствующий сервисный класс или Action для обработки и вернуть HTTP-ответ.

**Причина:** Это разделяет ответственности (SRP). Бизнес-логика становится переиспользуемой (например, в консольных командах) и легче тестируется независимо от HTTP-слоя.

**Пример:**
```php
// ✅ Правильно: Контроллер вызывает сервис
class OrderController extends Controller
{
    public function store(StoreOrderRequest $request, OrderService $orderService)
    {
        // 1. Валидация в FormRequest
        // 2. DTO для структурированных данных
        $orderData = OrderData::fromRequest($request);

        // 3. Вся работа выполняется в сервисе
        $order = $orderService->create($orderData);

        // 4. Возврат ответа
        return new OrderResource($order);
    }
}
```

### ❌ Неправильно: Бизнес-логика в контроллере

**Причина:** Код становится громоздким, его трудно читать и тестировать. Логика не может быть переиспользована в других частях приложения (например, в Artisan-команде).

**Пример:**
```php
// ❌ Неправильно: "Толстый" контроллер
class OrderController extends Controller
{
    public function store(Request $request)
    {
        // Валидация
        $validated = $request->validate([
            'user_id' => 'required|exists:users,id',
            'items' => 'required|array',
        ]);

        // Сложная бизнес-логика
        $totalPrice = 0;
        foreach ($validated['items'] as $item) {
            $product = Product::find($item['id']);
            if ($product->stock < $item['quantity']) {
                throw new \Exception('Недостаточно товара');
            }
            $totalPrice += $product->price * $item['quantity'];
        }

        // Взаимодействие с БД
        $order = Order::create([
            'user_id' => $validated['user_id'],
            'total' => $totalPrice,
        ]);

        // Отправка уведомлений
        Mail::to($request->user())->send(new OrderShipped($order));

        return response()->json($order);
    }
}
```

---

## 2. Модели и запросы к БД

### ✅ Правильно: Использовать Eager Loading для предотвращения N+1

При загрузке отношений всегда используйте "жадную" загрузку (`with()`), чтобы избежать проблемы "N+1 запросов".

**Причина:** Проблема N+1 — одна из главных причин низкой производительности. Вместо одного запроса для получения родительских моделей и ещё N запросов для их отношений, Eager Loading выполняет всего два запроса, что кардинально быстрее.

**Пример:**
```php
// ✅ Правильно: 2 запроса к БД
$posts = Post::with('author', 'comments')->get();

foreach ($posts as $post) {
    // Доступ к отношениям не вызывает новых запросов
    echo $post->author->name;
}
```

### ❌ Неправильно: Ленивая загрузка (Lazy Loading) в циклах

**Причина:** Этот код выполнит 1 запрос для получения всех постов, а затем ещё N запросов для получения автора каждого поста. Если постов 100, будет выполнен 101 запрос к БД.

**Пример:**
```php
// ❌ Неправильно: 1 + N запросов
$posts = Post::all();

foreach ($posts as $post) {
    // Этот вызов выполняет отдельный запрос к БД на каждой итерации!
    echo $post->author->name;
}
```

### ✅ Правильно: Выносить повторяющиеся запросы в Query Scopes

**Причина:** Это соответствует принципу DRY (Don't Repeat Yourself). Логика запроса инкапсулируется в одном месте, делая код чище и проще в поддержке.

**Пример:**
```php
// В модели Post.php
public function scopePublished(Builder $query): void
{
    $query->where('is_published', true)->where('published_at', '<=', now());
}

// В контроллере
$publishedPosts = Post::published()->get();
```

---

## 3. Безопасность и конфигурация

### ✅ Правильно: Использовать Mass Assignment с осторожностью

Используйте свойство `$fillable` или `$guarded` в моделях, чтобы явно указать, какие поля можно заполнять массово.

**Причина:** Это защищает от уязвимости Mass Assignment, когда злоумышленник может передать в запросе дополнительные поля (например, `is_admin=1`) и изменить данные, которые не должны были быть изменены.

**Пример:**
```php
// ✅ Правильно: в модели User.php
class User extends Model
{
    // Разрешаем массовое заполнение только этих полей
    protected $fillable = ['name', 'email', 'password'];

    // Или запрещаем заполнение этого поля (альтернатива)
    // protected $guarded = ['is_admin'];
}

// В контроллере
User::create($request->all()); // Безопасно
```

### ❌ Неправильно: Отключать защиту Mass Assignment

**Причина:** Полное отключение защиты (`$guarded = []`) открывает потенциальную уязвимость, если вы небрежно передаёте `$request->all()` в `create()` или `update()`.

### ✅ Правильно: Использовать `config()` вместо `env()`

В коде приложения всегда обращайтесь к переменным окружения через хелпер `config()`.

**Причина:**
1.  **Скорость:** Конфигурационные файлы кешируются командой `php artisan config:cache` в один файл для быстрой загрузки. Вызовы `env()` не кешируются и каждый раз читают `.env` файл, что медленнее.
2.  **Надёжность:** Если `.env` файл отсутствует (например, на продакшене, где переменные заданы на уровне сервера), вызов `env()` вернёт `null`, что может привести к ошибкам. `config()` вернёт значение по умолчанию.

**Пример:**
```php
// config/services.php
'github' => [
    'client_id' => env('GITHUB_CLIENT_ID'), // env() используется только здесь
    'secret' => env('GITHUB_SECRET'),
],

// ✅ Правильно: в коде приложения
$clientId = config('services.github.client_id');

// ❌ Неправильно:
$clientId = env('GITHUB_CLIENT_ID');
```

---

## 4. Общие принципы

### ✅ Правильно: Ранние возвраты (Early Returns)

Избегайте использования `else`. Проверяйте ошибочные условия в начале метода и сразу же выходите из него.

**Причина:** Это уменьшает вложенность и делает "счастливый путь" (happy path) — основной сценарий выполнения — более очевидным и лёгким для чтения.

**Пример:**
```php
// ✅ Правильно: плоский код
public function update(Request $request, Post $post)
{
    if (!$request->user()->can('update', $post)) {
        abort(403);
    }

    // Основная логика без вложенности
    $post->update($request->validated());
    return redirect()->route('posts.show', $post);
}
```

### ❌ Неправильно: Вложенные условия с `else`

**Причина:** Код становится похож на "лапшу", его трудно отслеживать и понимать.

**Пример:**
```php
// ❌ Неправильно: "код-стрела"
public function update(Request $request, Post $post)
{
    if ($request->user()->can('update', $post)) {
        // ...
        // Основная логика глубоко внутри условия
        // ...
        return redirect()->route('posts.show', $post);
    } else {
        abort(403);
    }
}
```

### ✅ Правильно: Не повторяться (DRY)

Используйте инструменты Laravel, чтобы избежать дублирования кода.

**Причина:** Повторение кода — источник ошибок. Изменение в одном месте потребует изменений во всех копиях.

**Примеры:**
| Проблема | ✅ Решение |
| :--- | :--- |
| Повторяющиеся блоки HTML | **Компоненты Blade** (`<x-button />`) |
| Повторяющиеся запросы к БД | **Query Scopes** в моделях |
| Повторяющаяся логика валидации | **Form Requests** |
| Повторяющийся код в контроллерах | Вынесение в **Actions** или **Services** |

### ✅ Правильно: Использовать коллекции

Предпочитайте коллекции Laravel массивам.

**Причина:** Коллекции предоставляют мощный, выразительный и интуитивно понятный API для работы с данными, что делает код более чистым и читаемым по сравнению с нативными функциями PHP для массивов.

**Пример:**
```php
// ✅ Правильно: цепочка вызовов коллекции
$activeUsers = collect($users)
    ->where('is_active', true)
    ->pluck('email')
    ->map(fn($email) => strtolower($email));

// ❌ Неправильно: сложная и менее читаемая работа с массивом
$activeUserEmails = [];
foreach ($users as $user) {
    if ($user['is_active']) {
        $activeUserEmails[] = strtolower($user['email']);
    }
}
```

### ✅ Правильно: Не размещать логику в Blade

Представления (Blade-файлы) должны быть максимально простыми и отвечать только за отображение данных.

**Причина:** Смешивание логики и отображения нарушает разделение ответственностей, усложняет тестирование и редизайн.

**Пример:**
```php
// ✅ Правильно: вся логика подготовлена в модели или контроллере

// В модели User.php
public function getFullNameAttribute(): string
{
    return $this->first_name . ' ' . $this->last_name;
}

// В Blade
<p>Имя: {{ $user->full_name }}</p>
<p>Статус: {{ $user->status->displayName() }}</p> {{-- Enum --}}
```

### ❌ Неправильно: Сложные вычисления или запросы в Blade

**Причина:** Это делает код в представлении грязным и может привести к неожиданным запросам к БД.

**Пример:**
```php
{{-- ❌ Неправильно: --}}
<p>Имя: {{ $user->first_name . ' ' . $user->last_name }}</p>

@if (auth()->user()->isAdmin() && $post->comments()->count() > 10)
    <p>Этот пост популярен!</p>
@endif
```
